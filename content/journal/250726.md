+++
title = "26_07_2025"
date = 2025-07-26
[taxonomies]
subject = ["rust"]
substance = ["high"]
+++

Use `stdout().flush()` before `io::stdin()` so that the program doesn't wait for input before the prompt is displayed.

By default, Rust buffers output. This means it collects characters in memory before showing them all at once, which helps with performance. However, if the program stops to wait for `stdin()`, the output will stay in the buffer until input is received and the program continues.

An empty `flush()` is okay for learning and development, especially considering `flush()` rarely fails, but in production the error should be handled properly:

```rust
if let Err(e) = io::stdout().flush() {
    // handle the error here
}
```

Use `as_str()` with match blocks because matching Strings is a bad idea.  
1. `"add" =>` won't match `String::from("add")` as they are different types; `"add"` is a `&'static str`.  
2. Match works best with copyable values. Matching against a `String` requires a full comparison with `eq()` in the backend, which is slower, and requires `.to_string()` on every line.  
3. You lose ownership of the string or need to borrow mutably, which becomes more verbose in the match arms and is more error-prone.  

Match arms need to all return the same type.

`HashMap` is good for fast lookup and removals at O(1) access speed by ID. It also avoids indexing problems compared to trying to solve the same problem with a `Vec`.

When using `impl` on a type and defining an `fn` for it, you need to pass `&self` as a parameter; otherwise, it is considered a static method and is not callable from an instance of the type.  

Use `&mut self` if the method changes the instance.

`remove()` on a `HashMap` returns an `Option<T>`, which is either `Some(T)` or `None`, so add an `is_some()` call and an `if`/`match` statement to cover all cases.

`HashMap::remove` expects to be passed a reference to the key, not the key itself â€” this is also more efficient, as it avoids unnecessary cloning or transferring.

