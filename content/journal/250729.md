+++
title = "29_07_2025"
date = 2025-07-29
[taxonomies]
subject = ["rust"]
substance = ["moderate"]
+++

`mod` keyword is used to bring local modules into scope, `use` is just an alias for easier use in the current file.

/// creates a doc comment, good for public apis or anything that might be reused or tested.

You cannot have immutable references or other mutable references active at the same time as a mutable reference.

You can have one, but not both:
1. Any number of immutable references.
2. One mutable reference.

Rust will not allow you to move a value while it's still borrowed - even mutably.

Function returning a reference can be ambiguous for the compiler to prove reference viability:

```rust
fn longest(x: &str, y: &str) -> &str {
    ...
}

let result = {
    let s1 = String::from("Hello");
    longest(&s1, &String::from("Bye"))
} // s1 and temporary reference are dropped here.

println!("{}", result); // result is now a dangling reference
```

Lifetimes are needed here to tell the compiler that the reference returned from the function is only valid for as long as the references passed to it with the same lifetime are valid. Since we don't know what reference will be returned, both will need to share the same lifetime:

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

Structs can never infer lifetimes, so if a field of a struct is a ref, then a lifetime needs to be specified:

```rust
struct Highlight<'a> {
    part: &'a str,
}
```

A new instance of highlight will not be able to outlive the &str reference it holds.

`matches!` macro is cool - returns true if the pattern matches, false if not.

`matches!(first_letter, 'a' | 'e' | 'i' | 'o' | 'u')`